    (..., ...); (..., ...); (..., ...); (..., ...); (..., ...); (..., ...);
    (..., ...); (..., ...); (..., ...); (..., ...); (..., ...); (..., ...);
    (..., ...); (..., ...); (..., ...); (..., ...); (..., ...)])
val layer5 : Z.t Matrix.t -> Matrix.arg -> Z.t = <fun>
val layer6_map : (Z.t * Z.t, Z.t) Map.t =
  (Map.of_list ~default:0 [((0, 9), -1); ((2, 9), -1); ((4, 9), -1)])
val layer6 : Z.t Matrix.t -> Matrix.arg -> Z.t = <fun>
val is_valid : Z.t * Z.t * Z.t * Z.t * 'a -> bool = <fun>
val condition1 : Z.t * 'a * 'b * Z.t * Z.t -> bool = <fun>
val run : Z.t * Z.t * Z.t * Z.t * Z.t -> Matrix.arg -> Z.t = <fun>
val property1 : Z.t * Z.t * Z.t * Z.t * Z.t -> bool = <fun>
val acas_xu_phi_1 : Z.t * Z.t * Z.t * Z.t * Z.t -> bool = <fun>
Goal:

is_valid x && condition1 x ==> property1 x.

1 nontautological subgoal.

Subgoal 1:

 H0. (-3) <= x.1
 H1. x.1 <= 3
 H2. (-3) <= x.2
 H3. x.2 <= 3
 H4. x.0 >= 0
 H5. x.3 >= 0
 H6. x.0 <= 55948
 H7. x.3 >= 1145
 H8. x.4 <= 60
|---------------------------------------------------------------------------
 C0. Matrix.fold_rec ( + ) 50 0 50
     (Matrix.map2 ( * )
      (Matrix.nth_row
       (fun _x
        -> begin match (_x : Matrix.arg) with
             | Matrix.Rows -> 5
             | Matrix.Cols -> 51
             | Matrix.Value ((i : int), (j : int)) ->
               Map.get (i, j) layer6_map
           end)
       (Destruct(Matrix.Value, 1, Matrix.Value (0, 0))))
      (FC.add_weight_coeff
       (((((layer0
            ((fun dist angle angle_int vown vint _y
              -> begin match (_y : Matrix.arg) with
                   | Matrix.Rows -> 1
                   | Matrix.Cols -> 5
                   | Matrix.Value ((_pat_var_3 : int), (_pat_var_4 : int)) ->
                     if 0 = _pat_var_4 && 0 = _pat_var_3 then dist
                     else
                     if 1 = _pat_var_4 && 0 = _pat_var_3 then angle
                     else
                     if 2 = _pat_var_4 && 0 = _pat_var_3 then angle_int
                     else
                     if 3 = _pat_var_4 && 0 = _pat_var_3 then vown
                     else
                     if 4 = _pat_var_4 && 0 = _pat_var_3 then vint else 0
                 end)
             x.0 x.1 x.2 x.3 x.4)
            |> layer1)
           |> layer2)
          |> layer3)
         |> layer4)
        |> layer5)))
     <= 0
 C1. Matrix.fold_rec ( + ) 50 0 50
     (Matrix.map2 ( * )
      (Matrix.nth_row
       (fun _x
        -> begin match (_x : Matrix.arg) with
             | Matrix.Rows -> 5
             | Matrix.Cols -> 51
             | Matrix.Value ((i : int), (j : int)) ->
               Map.get (i, j) layer6_map
           end)
       (Destruct(Matrix.Value, 1, Matrix.Value (0, 0))))
      (FC.add_weight_coeff
       (((((layer0
            ((fun dist angle angle_int vown vint _y
              -> begin match (_y : Matrix.arg) with
                   | Matrix.Rows -> 1
                   | Matrix.Cols -> 5
                   | Matrix.Value ((_pat_var_3 : int), (_pat_var_4 : int)) ->
                     if 0 = _pat_var_4 && 0 = _pat_var_3 then dist
                     else
                     if 1 = _pat_var_4 && 0 = _pat_var_3 then angle
                     else
                     if 2 = _pat_var_4 && 0 = _pat_var_3 then angle_int
                     else
                     if 3 = _pat_var_4 && 0 = _pat_var_3 then vown
                     else
                     if 4 = _pat_var_4 && 0 = _pat_var_3 then vint else 0
                 end)
             x.0 x.1 x.2 x.3 x.4)
            |> layer1)
           |> layer2)
          |> layer3)
         |> layer4)
        |> layer5)))
     <= 1500

But simplification reduces this to true, using the definition of
Matrix.fold_rec.

 ⓘ  Rules:
    (:def Matrix.fold_rec)

[✓] Theorem proved.

imandra_client < ./acas_xu_network.iml  9.52s user 0.28s system 10% cpu 1:33.78 total