(* forall F: CNN, forall i: happy-face-image :     left_diagonal_filter \in F AND right_diagonal_filter \in F AND pos_weights F  ==> F(i) = Happy *)

let (>>=) = Res.bind
let (=?) = Res.eq
let (>=?) = Res.gte

let make_cnn w0 w4 = 
    let layer_0 = Layer.convolution w0 in
    let layer_1 = Layer.max_pool (2,2) in
    let layer_2 = Layer.flatten in
    let layer_4 = Layer.fc (fun x -> x) w4 in
    fun input -> layer_0 input >>= layer_1 >>= layer_2 >>= layer_4 >>= arg_max
;;


let check_weights_dimensions w0 w4 = 
    let open Matrix in
    let (rows_0, cols_0) = dimensions w0 in
    let (rows_4, cols_4) = dimensions w4 in
    ((rows_0, cols_0) = (2,2)) &&  
    ((rows_4, cols_4) = (2,33))
;;
(* replace dimensions with correct measures *)


let is_left_diagonal (m: 'a Matrix.t) ((i,j): int*int) : bool = 
    let is_valid m = (Matrix.dimensions m) = (3, 3) in
    (
        is_valid m && 
        (Matrix.nth (0+i, 0+j) m)  =? (Ok 1.) && 
        (Matrix.nth (0+i, 1+j) m)  =? (Ok 0.) &&
        (Matrix.nth (0+i, 2+j) m)  =? (Ok 0.) &&
        (Matrix.nth (1+i, 0+j) m)  =? (Ok 0.) && 
        (Matrix.nth (1+i, 1+j) m)  =? (Ok 1.) && 
        (Matrix.nth (1+i, 2+j) m)  =? (Ok 0.) && 
        (Matrix.nth (2+i, 0+j) m)  =? (Ok 0.) && 
        (Matrix.nth (2+i, 1+j) m)  =? (Ok 0.) && 
        (Matrix.nth (2+i, 2+j) m)  =? (Ok 1.)
    )
;;

let is_left_diagonal_present m = 
    let open Matrix in    
    (
        (is_left_diagonal m (4,0)) ||
        (is_left_diagonal m (5,0)) ||
        (is_left_diagonal m (6,0)) ||
        (is_left_diagonal m (4,1)) ||
        (is_left_diagonal m (5,1)) ||
        (is_left_diagonal m (6,1)) ||
        (is_left_diagonal m (4,2)) ||
        (is_left_diagonal m (5,2)) ||
        (is_left_diagonal m (6,2))
    )

let is_right_diagonal (m: 'a Matrix.t) ((i,j): int*int): bool = 
    let is_valid m = (Matrix.dimensions m) = (3, 3) in
    (
        is_valid m && 
        (Matrix.nth (0+i, 0+j) m)  =? (Ok 0.) && 
        (Matrix.nth (0+i, 1+j) m)  =? (Ok 0.) &&
        (Matrix.nth (0+i, 2+j) m)  =? (Ok 1.) &&
        (Matrix.nth (1+i, 0+j) m)  =? (Ok 0.) && 
        (Matrix.nth (1+i, 1+j) m)  =? (Ok 1.) && 
        (Matrix.nth (1+i, 2+j) m)  =? (Ok 0.) && 
        (Matrix.nth (2+i, 0+j) m)  =? (Ok 1.) && 
        (Matrix.nth (2+i, 1+j) m)  =? (Ok 0.) && 
        (Matrix.nth (2+i, 2+j) m)  =? (Ok 0.)
    )
;;

let is_right_diagonal_present m = 
    let open Matrix in    
    (
        (is_right_diagonal m (4,4)) ||
        (is_right_diagonal m (5,4)) ||
        (is_right_diagonal m (6,4)) ||
        (is_right_diagonal m (4,5)) ||
        (is_right_diagonal m (5,5)) ||
        (is_right_diagonal m (6,5)) ||
        (is_right_diagonal m (4,6)) ||
        (is_right_diagonal m (6,5)) ||
        (is_right_diagonal m (6,6))
    )

let is_happy_image (m: 'a Matrix.t) =
    let open Matrix in  
    is_left_diagonal_present m &&
    is_right_diagonal_present m

let input = [
        [ 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0];
        [ 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0];
        [ 0.0; 0.0; 1.0; 0.0; 0.0; 0.0; 0.0; 1.0; 0.0];
        [ 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0];
        [ 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0];
        [ 0.0; 1.0; 0.0; 0.0; 0.0; 0.0; 0.0; 1.0; 0.0];
        [ 0.0; 0.0; 1.0; 0.0; 0.0; 0.0; 1.0; 0.0; 0.0];
        [ 0.0; 0.0; 0.0; 1.0; 1.0; 1.0; 0.0; 0.0; 0.0];
        [ 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0];
];;

let is_right_diagonal_filter (filter: (('a Matrix.t), 'b) result): bool =
    (
        (Res.map Matrix.dimensions filter) = (Ok (2, 2)) &&    
        (filter >>= (Matrix.nth (0,0))) =? (Ok 0.) &&
        (filter >>= (Matrix.nth (0,1))) =? (Ok 1.) &&
        (filter >>= (Matrix.nth (1,0))) =? (Ok 1.) &&
        (filter >>= (Matrix.nth (1,1))) =? (Ok 0.)
    )
   
let has_right_diagonal_filter (w: ('a Matrix.t) Vec.t) = 
    (is_right_diagonal_filter (Matrix.nth (0,0) w)) || 
    (is_right_diagonal_filter (Matrix.nth (1,0) w))

let is_left_diagonal_filter (filter: (('a Matrix.t), 'b) result): bool =
    (
        (Res.map Matrix.dimensions filter) = (Ok (2, 2)) &&    
        (filter >>= Matrix.nth (0,0)) =? (Ok 1.) &&
        (filter >>= Matrix.nth (0,1)) =? (Ok 0.) &&
        (filter >>= Matrix.nth (1,0)) =? (Ok 0.) &&
        (filter >>= Matrix.nth (1,1)) =? (Ok 1.)
    )
   
let has_left_diagonal_filter (w: ('a Matrix.t) Vec.t) = 
    (is_left_diagonal_filter (Matrix.nth (0,0) w)) || 
    (is_left_diagonal_filter (Matrix.nth (1,0) w))

let check_fully_connected_weights (w: 'a Matrix.t) : bool = 
    let left_corner_correlation = (
        ((Matrix.nth (0, 17)) w >=? (Ok 0.)) ||
        ((Matrix.nth (0, 19)) w >=? (Ok 0.)) ||
        ((Matrix.nth (0, 25)) w >=? (Ok 0.)) ||
        ((Matrix.nth (0, 27)) w >=? (Ok 0.))
    ) in 
    let right_corner_correlation = (
        ((Matrix.nth (0, 22)) w >=? (Ok 0.)) ||
        ((Matrix.nth (0, 24)) w >=? (Ok 0.)) ||
        ((Matrix.nth (0, 30)) w >=? (Ok 0.)) ||
        ((Matrix.nth (0, 32)) w >=? (Ok 0.))
    ) in
    left_corner_correlation && right_corner_correlation


let filter_adequacy_happy w0 w4 i = 
    let f = make_cnn w0 w4 in
    (
        is_happy_image i &&
        check_weights_dimensions w0 w4 &&
        has_left_diagonal_filter w0 &&
        has_right_diagonal_filter w0 &&
        check_fully_connected_weights w4
    ) ==> (f [i]) = (Ok "Happy") 
;;