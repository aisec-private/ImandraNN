(* forall F: CNN, forall i: happy-face-image :     left_diagonal_filter \in F AND right_diagonal_filter \in F AND pos_weights F  ==> F(i) = Happy *)

let (>>=) = Res.bind
let (=?) = Res.eq
let (>=?) = Res.gte

let make_cnn w0 w4 = 
    let layer_0 = Layer.convolution w0 in
    let layer_1 = Layer.max_pool (2,2) in
    let layer_2 = Layer.flatten in
    let layer_4 = Layer.fc (fun x -> x) w4 in
    fun input -> layer_0 input >>= layer_1 >>= layer_2 >>= layer_4 >>= arg_max
;;


let check_weights_dimensions w0 w4 = 
    let open Matrix in
    let (rows_0, cols_0) = dimensions w0 in
    let (rows_4, cols_4) = dimensions w4 in
    ((rows_0, cols_0) = (2,2)) &&  
    ((rows_4, cols_4) = (2,33))
;;
(* replace dimensions with correct measures *)


let is_left_diagonal (m: 'a Matrix.t) ((i,j): int*int) : bool = 
    let is_valid m = (Matrix.dimensions m) = (9, 9) in
    (
        is_valid m && 
        (Matrix.nth (0+i, 0+j) m)  =? (Ok 1.) && 
        (Matrix.nth (0+i, 1+j) m)  =? (Ok 0.) &&
        (Matrix.nth (0+i, 2+j) m)  =? (Ok 0.) &&
        (Matrix.nth (1+i, 0+j) m)  =? (Ok 0.) && 
        (Matrix.nth (1+i, 1+j) m)  =? (Ok 1.) && 
        (Matrix.nth (1+i, 2+j) m)  =? (Ok 0.) && 
        (Matrix.nth (2+i, 0+j) m)  =? (Ok 0.) && 
        (Matrix.nth (2+i, 1+j) m)  =? (Ok 0.) && 
        (Matrix.nth (2+i, 2+j) m)  =? (Ok 1.)
    )
;;

let is_left_diagonal_present m = 
    let open Matrix in    
    (
        (is_left_diagonal m (4,0)) ||
        (is_left_diagonal m (5,0)) ||
        (is_left_diagonal m (6,0)) ||
        (is_left_diagonal m (4,1)) ||
        (is_left_diagonal m (5,1)) ||
        (is_left_diagonal m (6,1)) ||
        (is_left_diagonal m (4,2)) ||
        (is_left_diagonal m (5,2)) ||
        (is_left_diagonal m (6,2))
    )

let is_right_diagonal (m: 'a Matrix.t) ((i,j): int*int): bool = 
    let is_valid m = (Matrix.dimensions m) = (9, 9) in
    (
        is_valid m && 
        (Matrix.nth (0+i, 0+j) m)  =? (Ok 0.) && 
        (Matrix.nth (0+i, 1+j) m)  =? (Ok 0.) &&
        (Matrix.nth (0+i, 2+j) m)  =? (Ok 1.) &&
        (Matrix.nth (1+i, 0+j) m)  =? (Ok 0.) && 
        (Matrix.nth (1+i, 1+j) m)  =? (Ok 1.) && 
        (Matrix.nth (1+i, 2+j) m)  =? (Ok 0.) && 
        (Matrix.nth (2+i, 0+j) m)  =? (Ok 1.) && 
        (Matrix.nth (2+i, 1+j) m)  =? (Ok 0.) && 
        (Matrix.nth (2+i, 2+j) m)  =? (Ok 0.)
    )
;;

let is_right_diagonal_present m = 
    let open Matrix in    
    (
        (is_right_diagonal m (4,4)) ||
        (is_right_diagonal m (5,4)) ||
        (is_right_diagonal m (6,4)) ||
        (is_right_diagonal m (4,5)) ||
        (is_right_diagonal m (5,5)) ||
        (is_right_diagonal m (6,5)) ||
        (is_right_diagonal m (4,6)) ||
        (is_right_diagonal m (6,5)) ||
        (is_right_diagonal m (6,6))
    )

let is_happy_image (m: 'a Matrix.t) =
    let open Matrix in  
    is_left_diagonal_present m &&
    is_right_diagonal_present m

let input = [
        [ 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0];
        [ 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0];
        [ 0.0; 0.0; 1.0; 0.0; 0.0; 0.0; 0.0; 1.0; 0.0];
        [ 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0];
        [ 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0];
        [ 0.0; 1.0; 0.0; 0.0; 0.0; 0.0; 0.0; 1.0; 0.0];
        [ 0.0; 0.0; 1.0; 0.0; 0.0; 0.0; 1.0; 0.0; 0.0];
        [ 0.0; 0.0; 0.0; 1.0; 1.0; 1.0; 0.0; 0.0; 0.0];
        [ 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0];
];;

let check_fully_connected_weights (w: 'a Matrix.t) : bool = 
    let left_corner_correlation = (
        (Matrix.argmax w =? (Ok (0, 16))) ||
        (Matrix.argmax w =? (Ok (0, 18))) ||
        (Matrix.argmax w =? (Ok (0, 24))) ||
        (Matrix.argmax w =? (Ok (0, 26)))
    ) in 
    let right_corner_correlation = (
        (Matrix.argmax w =? (Ok (0, 21))) ||
        (Matrix.argmax w =? (Ok (0, 23))) ||
        (Matrix.argmax w =? (Ok (0, 29))) ||
        (Matrix.argmax w =? (Ok (0, 31)))
    ) in
    left_corner_correlation || right_corner_correlation

(* f(x) = happy, if the sum of activations of the FC layer x*w_1 + ... + x*nw_n  is higher than the sum  x*w_n+1 + ... + x*w_n+n *)
let is_happy input weights =
    let layer_4 = Layer.fc (fun x -> x) weights in
    match (input >>= layer_4) with
        | Ok (x::y::[]) -> x >. y
        | _ -> false

let max_bottom_left_corner (m: ('a Matrix.t, 'b) result) = 
    (Res.map Matrix.dimensions m) = (Ok (4,4)) &&    
    ((m >>= Matrix.argmax) = (Ok (2,0)) || (m >>= Matrix.argmax) = (Ok (3,1))) 

let max_bottom_right_corner (m: ('a Matrix.t, 'b) result) = 
    (Res.map Matrix.dimensions m) = (Ok (4,4)) &&    
    ((m >>= Matrix.argmax) = (Ok (2,3)) || (m >>= Matrix.argmax) = (Ok (3,2))) 

let has_pattern (m: (('a Matrix.t) Vec.t)): bool =
    max_bottom_left_corner (Vec.nth 0 m) &&
    max_bottom_right_corner (Vec.nth 1 m)

let tuned_weights max_pool_output weights =
    (has_pattern max_pool_output) && (check_fully_connected_weights weights) ==> is_happy (Layer.flatten max_pool_output) weights


(* 3. an adequate happy filter is the one that has the pooling layers shape S* for ideal happy image *)
let check_adequate_happy_filter i (w: ('a Matrix.t) Vec.t): bool = 
    let layer0 = Layer.convolution w in
    is_happy_image i ==> (Res.map has_pattern (layer0 [i])) = (Ok true)

(* Theorem: given a happy image x, an adequate filter and tuned weights, f(x) = Happy *)
let filter_adequacy_happy w0 w4 i = 
    let layer0 = Layer.convolution Weight.layer0 in
    let f = make_cnn w0 w4 in
    (
        is_happy_image i &&
        (* check_weights_dimensions w0 w4 && *)
        check_adequate_happy_filter i w0 &&
        tuned_weights  (layer0 [i]) w4
    ) ==> (f [i]) = (Ok "Happy")
;;

