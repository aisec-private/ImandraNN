(* let () = System.use "acas_xu_network.iml";; *)

let relu = FC.relu;;

let is_valid (dist, angle, angle_int, vown, vint) =
  -3.14159 <=. angle && angle <=. 3.14159 &&        (* angles are in [-pi, pi] *)
  -3.14159 <=. angle_int && angle_int <=. 3.14159 &&
  dist >=. 0. && vown >=. 0. && vint >=. 0. (* speed and distances are positive *)

let precondition1 (dist, angle, angle_int, vown, vint) =
  (dist >=. 55948.) && (vown >=. 1145.) && (vint <=. 60.)

let postcondition1 output =
  let coc = Matrix.nth output (0,0) in
  coc <=. 1500.
;

(* let postcondition2 x =
  let output = run x in
  let g i j = Matrix.to_val @@ output (Value (i,j)) in
  let coc = g -1 0 in
  let weak_left = g -1 1 in
  let weak_right = g -1 2 in
  let strong_left = g -1 3 in
  let strong_right = g -1 4 in
  (weak_left >=. coc
   || weak_right >=. coc
   || strong_left >=. coc
   || strong_right >=. coc)
;; *)

(* We prove characterizing forward-chaining rules about `relu`,
   and then we disable it for all of the proofs. This way,
   `relu` induces no simplification case-splits, while all
   relevant information about `relu` values is propagated,
   per instance, on demand to our simplification context. *)

lemma relu_pos x =
  x >=. 0. ==> (relu x) [@trigger] = x
[@@auto] [@@fc]
;;

lemma relu_neg x =
  x <=. 0. ==> (relu x) [@trigger] = 0.
[@@auto] [@@fc]
;;

#disable relu;;

(* theorem property1 x =
  is_valid x && precondition1 x ==> postcondition1 (run x)
[@@auto]
;;

theorem property2 x =
  is_valid x && precondition2 x ==> postcondition2 x
[@@auto]
;; *)
